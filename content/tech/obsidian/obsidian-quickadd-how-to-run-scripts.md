---
date: 2023-05-26
cssclasses:
  - hide-props-for-blog
type: page
path: content/tech/obsidian
filename: obsidian-quickadd-how-to-run-scripts
title: Obsidian QuickAdd - как запускать скрипты
share: true
menu: true
blog: false
toc: true
collapse: false
weight: 10
Статус:
  - закончено
tags:
  - Obsidian
  - QuickAdd
summary: Плагин для Обсидиана QuickAdd позволяет автоматически создавать заметки, но ещё его можно использовать в качестве запускалки скриптов.
---



Плагин для [[../../../Obsidian|Обсидиана]] [[QuickAdd|QuickAdd]] позволяет автоматически создавать заметки, но ещё его можно использовать в качестве запускалки скриптов.

## Javascript
- Создать файл в формате js и сохранить его в любом месте хранилища.
- В файле написать код:

```js
module.exports =  async (params) => {
    
  /Мой код. В нём можно использовать API Обсидиана и самого плагина./

}
```

- В настройках QuickAdd создать макрос и в настройках макроса выбрать созданный скрипт.
- Не забыть отметить значок молнии рядом с названием макроса, чтобы активировалась команда. Потом эту команду можно подвязать на хоткей или добавить кнопочку с помощью плагина Commander.

## Другие языки и прочие файлы 
QuickAdd не может сам исполнять код на других языках, но может открывать файлы в программе по умолчанию, что позволяет нам запускать, например, shell-скрипты или любые другие файлы, для которых у нас установлена соответствующая программа.

- Нужно добавить файл, который мы хотим запустить, в хранилище. Например, это может быть bash-файл, который коммитит и пушит заметки на гитхаб.
- Создать js-скрипт и макрос по инструкции выше. 
- В js-файле написать код:

```js
module.exports =  async (params) => {
  
  let scriptPath = "\\scripts\\myFile.sh" /Здесь вместо моего примера надо указать путь к файлу, который мы хотим запустить. Путь указывается относительно хранилища. Обязательно надо эскейпить обратные слэши/

  let cmd = this.app.vault.adapter.basePath + scriptPath
  const { promisify } = require('util'); 
  const exec = promisify(require('child_process').exec); 
  await exec(cmd);

}
```

Этот скрипт запускает файлы на Windows. В других системах код может отличаться, в частности, путь будет записываться прямыми слэшами, но может, есть и другие нюансы, не знаю. Поскольку мы не прописываем напрямую путь к хранилищу, а находим его с помощью кода, этот скрипт может работать на разных устройствах.

## Запрашивать подтверждение перед выполнением скрипта
Это может быть полезно, если скрипт делает что-то опасное, или если мы используем автоматизированный запуск скрипта, но иногда хотим от него отказаться. Например, у меня настроен скрипт, который делает пул с гитхаба каждый раз при запуске программы, но иногда я закрываю и открываю Обсидиан несколько раз в течение рабочего дня и не вижу смысла каждый раз пулить.

```js
module.exports =  async (params) => {

  const { quickAddApi: { yesNoPrompt } } = params;
  const runScript = await yesNoPrompt("Выполнить скрипт?");

  if (runScript) {

    /Здесь пишем код, который будет выполняться при подтверждении/
  }
}
```

## Вызывать системные команды Обсидиана изнутри скрипта
Вообще-то QuickAdd может сам вызывать команды через макрос, безо всяких скриптов. Но иногда нам может понадобиться обернуть команду в какой-то код, и для этого нам поможет такой скрипт:

```js
module.exports =  async (params) => {

  /Какой-то код/
  
  await app.commands.executeCommandById(id) /где id — это id конкретной команды/
  
  /Какой-то код/

}
```

Чтобы узнать id команды, можно открыть консоль и написать код:

```js
console.log(app.commands.commands)
```

Это выведет список всех доступных на данный момент команд, включая команды из установленных плагинов, где указаны их названия и id.

## Пример — скрипты для обновления вкладок
В качестве бонуса — парочка маленьких полезных скриптов, который могут пригодиться.

Скрипт, чтобы обновить текущую активную вкладку:

```js
module.exports =  async (params) => {

   await app.workspace.activeLeaf.rebuildView()
}
```

Скрипт, чтобы обновить все открытые вкладки:

```js
module.exports =  async (params) => {

  await app.workspace.rightSplit.children.forEach(pane => {

    pane.children[pane.currentTab].rebuildView()
  })

  await app.workspace.leftSplit.children.forEach(pane => {

    pane.children[pane.currentTab].rebuildView()
  })

  await app.workspace.rootSplit.children.forEach(pane => {

    pane.children[pane.currentTab].rebuildView()
  })
}
```

Обновление вкладок может быть полезно при использовании некоторых плагинов, например Dataview и Supercharged Links, потому что они не всегда обновляют вид в реальном времени.
